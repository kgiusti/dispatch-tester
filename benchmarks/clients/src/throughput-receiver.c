/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */


/* The receiver for messages generated by throughput-sender
 */


#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <inttypes.h>
#include <math.h>

#include "proton/reactor.h"
#include "proton/message.h"
#include "proton/connection.h"
#include "proton/session.h"
#include "proton/link.h"
#include "proton/delivery.h"
#include "proton/event.h"
#include "proton/handlers.h"


bool stop = false;

uint64_t start_ts;  // start timestamp
uint64_t stop_ts;   // stop timestamp

int  credit_window = 1000;
char *source_address = "test-throughput";  // name of the source node to receive from
char *host_address = "127.0.0.1:5672";
char *container_name = "ThroughputReceiver";
bool server_mode = false;
bool bytes_throughput = false;  // compute byte throughput

pn_acceptor_t *acceptor;
pn_connection_t *pn_conn;
pn_session_t *pn_ssn;
pn_link_t *pn_link;
pn_reactor_t *reactor;

uint64_t count = 0;
uint64_t limit = 0;   // if > 0 stop after limit messages arrive
size_t total_bytes = 0;

char scratch[2097152];

// microseconds per second
#define USECS_PER_SECOND 1000000

// return wallclock time in microseconds since Epoch
//
static uint64_t now_usec(void)
{
    struct timespec ts;
    int rc = clock_gettime(CLOCK_REALTIME, &ts);
    if (rc) {
        perror("clock_gettime failed");
        exit(errno);
    }

    return (USECS_PER_SECOND * (uint64_t)ts.tv_sec) + (ts.tv_nsec / 1000);
}


static void signal_handler(int signum)
{
    signal(SIGINT,  SIG_IGN);
    signal(SIGQUIT, SIG_IGN);

    switch (signum) {
    case SIGINT:
    case SIGQUIT:
        stop = true;
        if (!stop_ts) stop_ts = now_usec();
        if (reactor) pn_reactor_wakeup(reactor);
        break;
    default:
        break;
    }
}


// Called when reactor exits to clean up app_data
//
static void delete_handler(pn_handler_t *handler)
{
}


// process PN_DELIVERY event
//
static void handle_delivery(pn_delivery_t *dlv)
{
    if (limit && count == limit) return;

    if (pn_delivery_readable(dlv) && !pn_delivery_partial(dlv)) {
        // A full message has arrived
        if (!start_ts) start_ts = now_usec();
        count += 1;

        pn_delivery_update(dlv, PN_ACCEPTED);

        if (bytes_throughput) {
            ssize_t rc = 0;
            while ((rc = pn_link_recv(pn_delivery_link(dlv), &scratch[0], sizeof(scratch))) != PN_EOS) {
                total_bytes += rc;
            }
        }

        pn_delivery_settle(dlv);  // dlv is now freed

        if (limit && count == limit) {
            stop = true;
            if (!stop_ts) stop_ts = now_usec();
            pn_reactor_wakeup(reactor);
        } else if (pn_link_credit(pn_link) <= credit_window/2) {
            // Grant enough credit to bring it up to CAPACITY:
            int grant = credit_window - pn_link_credit(pn_link);
            if (limit && (limit - count) < grant) {
                // don't grant more than we want to receive
                grant = limit - count;
            }
            if (grant) {
                //fprintf(stdout, "Granting credit %d\n", grant);
                pn_link_flow(pn_link, credit_window - pn_link_credit(pn_link));
            }
        }
    }
}


/* Handle connection events for connections initiated by
 * this container
 */
static void outgoing_conn_event_handler(pn_handler_t *handler,
                                        pn_event_t *event,
                                        pn_event_type_t type)
{
    //fprintf(stdout, "OUT_CONN_EVENT_HANDLER: %s\n", pn_event_type_name(type));
    switch (type) {

    case PN_CONNECTION_INIT: {
        pn_connection_open(pn_conn);

        // initiate endpoint setup
        pn_ssn = pn_session(pn_conn);
        pn_session_open(pn_ssn);
        pn_link = pn_receiver(pn_ssn, "MyReceiver");
        pn_terminus_set_address(pn_link_source(pn_link), source_address);
        pn_link_open(pn_link);
        // cannot receive without granting credit:
        pn_link_flow(pn_link, credit_window);

    } break;

    case PN_DELIVERY: {
        // A message has been received
        //
        handle_delivery(pn_event_delivery(event));
    } break;

    default:
        break;
    }
}


/* Handle connection events for connections initiated by
 * a remote endpoint
 */
static void incoming_conn_event_handler(pn_handler_t *handler,
                                        pn_event_t *event,
                                        pn_event_type_t type)
{
    //fprintf(stdout, "IN_CONN_EVENT_HANDLER: %s\n", pn_event_type_name(type));
    switch (type) {

    case PN_SESSION_REMOTE_OPEN:
    {
        assert(!pn_ssn);
        pn_ssn = pn_event_session(event);
        pn_session_open(pn_ssn);
    }
    break;

    case PN_LINK_REMOTE_OPEN:
    {
        assert(!pn_link);
        pn_link = pn_event_link(event);
        pn_terminus_set_address(pn_link_source(pn_link), source_address);
        pn_link_open(pn_link);
        pn_link_flow(pn_link, credit_window);
    }
    break;

    case PN_DELIVERY: {
        // A message has been received
        //
        handle_delivery(pn_event_delivery(event));
    } break;

    case PN_CONNECTION_REMOTE_CLOSE: {
        if (!stop_ts) stop_ts = now_usec();
        assert(acceptor);
        pn_acceptor_close(acceptor);  // this will exit the test
    } break;

    default:
        break;
    }
}


/* Process listener (server socket) events
 */
static void acceptor_event_handler(pn_handler_t *handler,
                                   pn_event_t *event,
                                   pn_event_type_t type)
{
    assert(server_mode);
    //fprintf(stdout, "ACCEPTOR_EVENT_HANDLER: %s\n", pn_event_type_name(type));

    switch (type) {
    case PN_CONNECTION_INIT:
    {
        // New incoming connection on listener socket.
        // There can be only one.
        if (pn_conn) {
            fprintf(stderr, "Rejecting additional connection attempts\n");
            pn_connection_close(pn_event_connection(event));
        } else {
            pn_conn = pn_event_connection(event);
            pn_handler_t *handler = pn_handler_new(incoming_conn_event_handler, 0, delete_handler);
            pn_handler_add(handler, pn_handshaker());
            pn_record_t *record = pn_connection_attachments(pn_conn);
            pn_record_set_handler(record, handler);

            pn_connection_set_container(pn_conn, container_name);
            pn_connection_set_hostname(pn_conn, host_address);

            //endpoints_setup(pn_conn);
        }
    }
    break;
    case PN_REACTOR_QUIESCED:
    {
    }
    break;
    case PN_REACTOR_INIT:
    {
    }
    break;
    case PN_REACTOR_FINAL:
    {
    }
    break;
    default:
        break;
    }
}


static void usage(void)
{
  printf("Usage: receiver <options>\n");
  printf("-a      \tThe host address [%s]\n", host_address);
  printf("-c      \tExit after N messages arrive (0 == run forever) [%"PRIu64"]\n", limit);
  printf("-i      \tContainer name [%s]\n", container_name);
  printf("-s      \tSource address [%s]\n", source_address);
  printf("-w      \tCredit window [%d]\n", credit_window);
  printf("-S      \tServer mode (accept connection requests)\n");
  printf("-B      \tReport byte throughput\n");
  exit(1);
}


int main(int argc, char** argv)
{
    /* command line options */
    opterr = 0;
    int c;
    while((c = getopt(argc, argv, "i:a:s:hw:c:BS")) != -1) {
        switch(c) {
        case 'h': usage(); break;
        case 'a': host_address = optarg; break;
        case 'c':
            if (sscanf(optarg, "%"PRIu64, &limit) != 1)
                usage();
            break;
        case 'i': container_name = optarg; break;
        case 's': source_address = optarg; break;
        case 'B': bytes_throughput = true; break;
        case 'S': server_mode = true; break;
        case 'w':
            if (sscanf(optarg, "%d", &credit_window) != 1 || credit_window <= 0)
                usage();
            break;

        default:
            usage();
            break;
        }
    }

    signal(SIGQUIT, signal_handler);
    signal(SIGINT,  signal_handler);

    reactor = pn_reactor();

    if (server_mode) {
        char *host = 0;
        char *port = 0;
        const char *foo = strrchr(host_address, ':');
        if (foo) {
            const size_t hlen = foo - host_address;
            if (hlen) {
                host = malloc(hlen + 1);
                memcpy(host, host_address, hlen);
                host[hlen] = 0;
            }
            const size_t plen = strlen(foo + 1);
            if (plen) {
                port = malloc(plen + 1);
                memcpy(port, (foo + 1), plen);
                port[plen] = 0;
            }
        }
        if (!host) host = strdup(host_address);
        if (!port) port = strdup("5672");

        //fprintf(stdout, "HOST='%s' PORT='%s'\n", host, port);
        pn_handler_t *handler = pn_handler_new(acceptor_event_handler, 0, delete_handler);
        acceptor = pn_reactor_acceptor(reactor, host, port, handler);
        if (!acceptor) abort();
        free(host);
        free(port);
    } else {
        pn_handler_t *handler = pn_handler_new(outgoing_conn_event_handler, 0, delete_handler);
        pn_handler_add(handler, pn_handshaker());
        pn_conn = pn_reactor_connection(reactor, handler);

        // the container name should be unique for each client
        pn_connection_set_container(pn_conn, container_name);
        pn_connection_set_hostname(pn_conn, host_address);
    }

    // periodic wakeup to print current stats
    pn_reactor_set_timeout(reactor, 10000);

    pn_reactor_start(reactor);

    while (pn_reactor_process(reactor)) {
        if (stop) {
            // eventually break the loop
            if (pn_link) pn_link_close(pn_link);
            if (pn_ssn) pn_session_close(pn_ssn);
            if (pn_conn) pn_connection_close(pn_conn);
            if (acceptor) pn_acceptor_close(acceptor);
        }
    }

    if (count) {
        double duration_sec = (double)(stop_ts - start_ts) / (double)USECS_PER_SECOND;
        printf("%s:  Throughput:  count: %"PRIu64" rate: %.3f msgs/sec",
               container_name,
               count, (duration_sec > 1.0) ? count / duration_sec : count * 1.0);
        if (total_bytes) {
            printf(" rate: %.3f bytes/sec",
                   (duration_sec > 1.0) ? total_bytes / duration_sec : total_bytes * 1.0);
        }
        printf("\n");
    }

    return 0;
}
